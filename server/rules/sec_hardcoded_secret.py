"""Security rule: Detect hardcoded credentials and secrets in source code.

Flags hardcoded credentials/secrets embedded in source including known formats
(AWS keys, GitHub tokens, private keys), and high-entropy strings in secret-like
contexts. Recommends using vault/KMS, environment variables, or secret managers.

PERFORMANCE: Optimized to avoid regex compilation per-file and limit tree walks.
"""

import math
import re
from typing import Iterator
from engine.types import RuleMeta, Rule, RuleContext, Finding, Requires


# Pre-compiled patterns (compile once, reuse always)
# Key hints - require specific secret-related terms but include common patterns
_KEY_HINTS = re.compile(
    r"("
    r"secret[_\-]?key|api[_\-]?key|api[_\-]?secret|"  # API-related secrets
    r"password|passwd|pwd|"  # Password variants
    r"private[_\-]?key|signing[_\-]?key|encryption[_\-]?key|"  # Crypto keys
    r"auth[_\-]?token|auth[_\-]?key|access[_\-]?token|access[_\-]?key|"  # Auth tokens/keys
    r"bearer[_\-]?token|refresh[_\-]?token|"  # More tokens
    r"client[_\-]?secret|app[_\-]?secret|"  # OAuth/app secrets
    r"database[_\-]?password|db[_\-]?password|db[_\-]?pass|"  # DB credentials
    r"credentials?|"  # Generic credentials
    r"api_token|"  # Common api token pattern
    r"\bsecret\s*=|\btoken\s*="  # secret = or token = assignments
    r")", 
    re.I
)

# Known-format detectors (non-exhaustive, intentionally precise)
_KNOWN_REGEXES = [
    (re.compile(r"AKIA[0-9A-Z]{16}"), "Possible AWS Access Key ID"),
    (re.compile(r"ASIA[0-9A-Z]{16}"), "Possible AWS Temp Access Key ID"),
    (re.compile(r"(?i)aws(.{0,20})?(secret|access).{0,20}[0-9a-zA-Z/+]{35,}"), "Possible AWS Secret Access Key"),
    (re.compile(r"ghp_[0-9A-Za-z]{36}"), "Possible GitHub Personal Access Token"),
    (re.compile(r"gho_[0-9A-Za-z]{36}"), "Possible GitHub OAuth Access Token"),
    (re.compile(r"ghu_[0-9A-Za-z]{36}"), "Possible GitHub User-to-Server Token"),
    (re.compile(r"ghs_[0-9A-Za-z]{36}"), "Possible GitHub Server-to-Server Token"),
    (re.compile(r"ghr_[0-9A-Za-z]{36}"), "Possible GitHub Refresh Token"),
    (re.compile(r"xox[baprs]-[0-9A-Za-z\-]{10,48}"), "Possible Slack token"),
    (re.compile(r"AIza[0-9A-Za-z\-_]{35}"), "Possible Google API key"),
    (re.compile(r"sk_live_[0-9a-zA-Z]{24,}"), "Possible Stripe Live Secret"),
    (re.compile(r"sk_test_[0-9a-zA-Z]{24,}"), "Possible Stripe Test Secret"),
    (re.compile(r"-----BEGIN (?:RSA PRIVATE|EC PRIVATE|DSA PRIVATE|OPENSSH PRIVATE|PRIVATE) KEY-----", re.DOTALL), "Private key material"),
    (re.compile(r"(?i)ssh-rsa [A-Za-z0-9+/]{100,}={0,3}"), "Possible SSH public key blob"),
    (re.compile(r"(?i)basic [A-Za-z0-9+/=]{20,}"), "Possible Basic auth header"),
    (re.compile(r"(?i)bearer [A-Za-z0-9\-_=]+\.[A-Za-z0-9\-_=]+\.?[A-Za-z0-9\-_.+/=]*"), "Possible JWT bearer token"),
]

# Extended allowlist - common false positive patterns
_ALLOWLIST_SUBSTRINGS = frozenset((
    "example", "sample", "dummy", "placeholder", "notsecret", "public", "test", "fake",
    "localhost", "127.0.0.1", "0.0.0.0", "mock", "demo", "fixture", "stub", "lorem", 
    "ipsum", "changeme", "your_", "your-", "<your", "[your", "{your", "xxx", "yyy",
    "replace_", "replace-", "insert_", "insert-", "todo", "fixme",
    # Template/auto-generated project patterns
    "secret-key", "secretkey", "default-secret", "development", "dev-only",
    "template", "generated", "autogenerated", "auto-generated",
    # Framework-specific defaults
    "fastapi-", "django-insecure", "flask-", "rails-secret", "spring-boot-"
))

# Minimum length for entropy checks - raised to reduce FPs
_MIN_LEN = 24
# Shannon entropy threshold - raised for tighter detection
_ENTROPY_THRESHOLD = 4.0

# Pre-compile rejection patterns
_URL_PATTERN = re.compile(r"https?://|ftp://|file://|www\.|mailto:")
_HEX_PATTERN = re.compile(r"^[0-9a-fA-F]{32,}$")
_UUID_PATTERN = re.compile(r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
# Additional false-positive patterns
_BASE64_DATA_URI = re.compile(r"^data:[a-z]+/[a-z]+;base64,")
_CSS_GRADIENT = re.compile(r"(linear|radial|conic)-gradient\(")
_PATH_PATTERN = re.compile(r"^(/[a-zA-Z0-9_\-./]+|[a-zA-Z]:\\\\|\\\\\\\\)")
_SEMVER_PATTERN = re.compile(r"^\d+\.\d+\.\d+")
_DATE_PATTERN = re.compile(r"^\d{4}-\d{2}-\d{2}")
_HASH_FRAGMENT = re.compile(r"^#[a-zA-Z0-9_\-]+$")
_EMAIL_PATTERN = re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
_PROSE_PATTERN = re.compile(r"\s{2,}|\.\s|,\s|\?\s|!\s")  # Multi-word prose with punctuation


class SecHardcodedSecretRule:
    """Detect hardcoded credentials and secrets in source code."""
    
    meta = RuleMeta(
        id="sec.hardcoded_secret",
        category="sec",
        tier=0,
        priority="P0",
        autofix_safety="suggest-only",
        description="Detect hardcoded credentials and secrets in source code",
        langs=["python", "typescript", "javascript", "go", "java", "cpp", "c", "csharp", "ruby", "rust", "swift", "sql"],
    )
    requires = Requires(syntax=True)

    # Auto-generated file patterns to skip
    AUTO_GENERATED_PATTERNS = [
        ".gen.", "generated", "_generated", ".generated",
        "sdk.gen", "client.gen", "api.gen",
        "openapi", "swagger",
        "auto-generated", "autogenerated",
        "do not edit", "do not modify",
    ]

    def visit(self, ctx) -> Iterator[Finding]:
        """Check for hardcoded secrets in string literals."""
        if not hasattr(ctx, 'tree') or not ctx.tree:
            return
        
        # Skip auto-generated files
        file_path_lower = ctx.file_path.lower() if ctx.file_path else ""
        if any(pattern in file_path_lower for pattern in self.AUTO_GENERATED_PATTERNS):
            return
            
        # Walk through all nodes to find string literals
        for lit in self._string_like_literals(ctx.tree):
            raw = self._get_node_text(lit)
            val = self._strip_quotes(raw)
            
            if not val or len(val) < 8:  # Quick length check
                continue
            
            # Skip module/package import paths (common false positives)
            # e.g., "@calcom/app-store/_appRegistry", "next/headers"
            if self._looks_like_import_path(val):
                continue
            
            # Skip template strings that reference environment variables
            # e.g., `Bearer ${process.env.CRON_SECRET}` - correct usage!
            if 'process.env.' in val or '${process.env' in val or 'os.environ' in val:
                continue
            
            # Skip i18n translation calls
            # e.g., `${t("message_key")}` - not secrets
            if '${t(' in val or '${t"' in val:
                continue
                
            val_lower = val.lower()
            if any(a in val_lower for a in _ALLOWLIST_SUBSTRINGS):
                continue
            
            # Skip code patterns that look like random generation, not secrets
            # e.g., Math.random(), crypto.randomBytes, uuid.v4()
            if any(pattern in val_lower for pattern in ['math.random', 'random()', 'uuid', 'crypto.random', 'getrandomvalues']):
                continue

            # 1) Check known secret formats (fast regex)
            for rx, label in _KNOWN_REGEXES:
                if rx.search(val):
                    start_pos, end_pos = ctx.tree.node_span(lit)
                    yield Finding(
                        rule=self.meta.id,
                        message=f"{label} found in source code—move to environment variable or secrets manager.",
                        file=ctx.file_path,
                        start_byte=start_pos,
                        end_byte=end_pos,
                        severity="error",
                    )
                    break
            else:
                # 2) Context + entropy heuristic (only for longer strings)
                if len(val) >= _MIN_LEN and self._looks_high_entropy(val):
                    # Only check context for high-entropy strings (expensive operation)
                    if self._near_secret_name(lit):
                        start_pos, end_pos = ctx.tree.node_span(lit)
                        yield Finding(
                            rule=self.meta.id,
                            message="Possible secret or API key in code—move sensitive values to environment variables.",
                            file=ctx.file_path,
                            start_byte=start_pos,
                            end_byte=end_pos,
                            severity="error",
                        )

    def _string_like_literals(self, syntax_tree):
        """Find all string-like literal nodes."""
        kinds = frozenset({
            "string_literal", "raw_string_literal", "bytes_literal", "char_array_literal",
            "sql_string_literal", "template_string", "heredoc_literal", "verbatim_string_literal",
            "interpreted_string_literal", "raw_string", "quoted_string", "string_value",
            "string"
        })
        
        for node in syntax_tree.walk():
            if hasattr(node, 'kind') and node.kind in kinds:
                yield node

    def _get_node_text(self, node) -> str:
        """Get text content of a node."""
        if hasattr(node, 'text'):
            return node.text.decode('utf-8') if isinstance(node.text, bytes) else str(node.text)
        return ""

    def _strip_quotes(self, s: str) -> str:
        """Strip quotes and prefixes from string literals."""
        s = s.strip()
        if len(s) < 2:
            return s
        # Handle raw strings (r"...", r'...', etc.)
        if s[0] in "rRbBuU" and len(s) > 2 and s[1] in "\"'":
            s = s[2:-1] if s[-1] == s[1] else s
        # Handle triple quotes
        elif s.startswith('"""') and s.endswith('"""') and len(s) >= 6:
            s = s[3:-3]
        elif s.startswith("'''") and s.endswith("'''") and len(s) >= 6:
            s = s[3:-3]
        # Handle regular quotes
        elif s[0] == s[-1] and s[0] in "'\"`":
            s = s[1:-1]
        return s

    def _looks_like_import_path(self, s: str) -> bool:
        """Check if string looks like a module/package import path.
        
        Common patterns:
        - @scope/package-name (npm scoped packages)
        - package/subpath (relative imports)
        - ./relative/path
        - ../parent/path
        """
        # NPM scoped packages: @scope/package
        if s.startswith('@') and '/' in s and not s.startswith('@:'):
            return True
        # Relative imports: ./foo, ../foo
        if s.startswith('./') or s.startswith('../'):
            return True
        # Common package import patterns (e.g., "next/headers", "react/jsx-runtime")
        if '/' in s and not s.startswith('http') and not s.startswith('Bearer'):
            parts = s.split('/')
            # Package imports typically have short, lowercase path segments
            if all(len(p) < 50 and p.replace('-', '').replace('_', '').isalnum() for p in parts if p):
                return True
        return False

    def _looks_high_entropy(self, s: str) -> bool:
        """Check if string has high entropy (likely random/secret-like)."""
        # Quick rejections for common non-secret patterns
        if _URL_PATTERN.search(s):
            return False
        if _HEX_PATTERN.match(s):  # hex digests (SHA, MD5, etc.)
            return False
        if _UUID_PATTERN.match(s):  # UUIDs
            return False
        if _BASE64_DATA_URI.match(s):  # data URIs
            return False
        if _CSS_GRADIENT.search(s):  # CSS gradients
            return False
        if _PATH_PATTERN.match(s):  # File paths
            return False
        if _SEMVER_PATTERN.match(s):  # Version strings
            return False
        if _DATE_PATTERN.match(s):  # Date strings
            return False
        if _HASH_FRAGMENT.match(s):  # URL hash fragments
            return False
        if _EMAIL_PATTERN.match(s):  # Email addresses
            return False
        if _PROSE_PATTERN.search(s):  # Multi-word text/prose
            return False
        
        # Reject API URL paths (e.g., /api/v1/login/access-token)
        if s.startswith('/') and '/' in s[1:]:
            return False
        
        # Reject strings that are mostly lowercase letters with spaces (prose)
        alpha_count = sum(1 for c in s if c.isalpha())
        space_count = s.count(' ')
        if space_count >= 2 and alpha_count / max(1, len(s)) > 0.7:
            return False
        
        # Reject common programming patterns
        if s.startswith('http') or s.startswith('ws://') or s.startswith('wss://'):
            return False
        if s.startswith('/api/') or s.startswith('/v1/') or s.startswith('/v2/'):
            return False
        if s.endswith('.com') or s.endswith('.org') or s.endswith('.io') or s.endswith('.net'):
            return False
        if s.startswith('npm:') or s.startswith('pip:') or s.startswith('gem:'):
            return False
        
        # Must have sufficient character diversity (secrets typically do)
        unique_chars = len(set(s))
        if unique_chars < 10:  # Too few unique characters
            return False
        
        # Calculate Shannon entropy
        freq = {}
        for ch in s:
            freq[ch] = freq.get(ch, 0) + 1
        
        length = len(s)
        H = -sum((c/length) * math.log2(c/length) for c in freq.values())
        return H >= _ENTROPY_THRESHOLD

    def _near_secret_name(self, lit) -> bool:
        """Check if literal appears in a secret-like context.
        
        Only triggers if the string is assigned to a variable/key with a secret-related name.
        Excludes cases where the secret-like term appears inside the literal value itself.
        """
        lit_text = self._get_node_text(lit)
        lit_value = self._strip_quotes(lit_text)
        
        # If the literal value itself contains secret-like terms (e.g., URL paths like
        # '/api/v1/login/access-token'), don't treat it as a secret context
        if _KEY_HINTS.search(lit_value):
            return False
        
        # Walk up max 2 levels to find immediate context
        current = lit
        for _ in range(2):
            if not current or not hasattr(current, 'parent'):
                break
            current = current.parent
            
            if hasattr(current, 'text'):
                parent_txt = self._get_node_text(current)
                if parent_txt:
                    idx = parent_txt.find(lit_text)
                    if idx > 0:
                        # Only check the immediate left context (80 chars before the literal)
                        # This should contain the variable/key name, not the value
                        left_ctx = parent_txt[max(0, idx-80):idx]
                        if _KEY_HINTS.search(left_ctx):
                            return True
        
        return False


# Export rule for registration
RULES = [SecHardcodedSecretRule()]


