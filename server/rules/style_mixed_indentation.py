"""
Rule: style.mixed_indentation

Detects mixed indentation (tabs + spaces) within the same file and provides
safe autofixes to normalize to a single indentation style.
"""

try:
    from ..engine.types import Rule, Finding, RuleMeta, Requires, RuleContext, Edit
except ImportError:
    try:
        from engine.types import Rule, Finding, RuleMeta, Requires, RuleContext, Edit
    except ImportError:
        # For test execution
        import sys
        import os
        sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
        from engine.types import Rule, Finding, RuleMeta, Requires, RuleContext, Edit

import re
from math import gcd
from typing import List, Tuple, Optional


class StyleMixedIndentationRule:
    """Detect and fix mixed indentation within files."""
    
    meta = RuleMeta(
        id="style.mixed_indentation",
        category="style",
        tier=0,
        priority="P2",
        autofix_safety="safe",
        description="Avoid mixing tabs and spaces for indentation; normalize to a single indentation style",
        langs=["python", "typescript", "javascript", "go", "java", "cpp", "c", "csharp", "ruby", "rust", "swift"]
    )
    
    requires = Requires(
        raw_text=True,
        syntax=True,
        scopes=False,
        project_graph=False
    )
    
    # Auto-generated file patterns to skip
    AUTO_GENERATED_PATTERNS = [
        ".gen.", "generated", "_generated", ".generated",
        "sdk.gen", "client.gen", "api.gen",
        "openapi", "swagger", "OpenAPI",
        "auto-generated", "autogenerated",
        "do not edit", "do not modify",
        "node_modules", "vendor", "dist/", "build/",
    ]
    
    def visit(self, ctx: RuleContext) -> List[Finding]:
        """Find mixed indentation in the file."""
        findings = []
        
        # Skip auto-generated files
        file_path_lower = ctx.file_path.lower() if ctx.file_path else ""
        if any(pattern.lower() in file_path_lower for pattern in self.AUTO_GENERATED_PATTERNS):
            return findings
        
        # Also check file content for auto-generated markers
        file_start = ctx.text[:500].lower() if ctx.text else ""
        if any(marker in file_start for marker in ['auto-generated', 'autogenerated', 'do not edit', 'generated file', 'this file is generated']):
            return findings
        
        # Check if this is a supported language
        # Check language compatibility
        language = getattr(ctx.adapter, 'language_id', 'unknown')
        if callable(language):
            language = language()

        if language not in self.meta.langs:
            return findings
        
        # Analyze indentation patterns
        indentation_info = self._collect_indentation_info(ctx.text)
        
        if not indentation_info:
            return findings
        
        # Check for mixed indentation
        has_tabs = any(info['has_tabs'] for info in indentation_info)
        has_spaces = any(info['has_spaces'] for info in indentation_info)
        
        if not (has_tabs and has_spaces):
            return findings  # No mixing detected
        
        # Find lines that have BOTH tabs and spaces (truly mixed)
        mixed_lines = [info for info in indentation_info 
                       if info['has_tabs'] and info['has_spaces']]
        
        # Also find lines that differ from the dominant style
        style, width = self._infer_preferred_style(indentation_info)
        inconsistent_lines = []
        for info in indentation_info:
            if style == "tabs" and info['has_spaces'] and not info['has_tabs']:
                inconsistent_lines.append(info)
            elif style == "spaces" and info['has_tabs'] and not info['has_spaces']:
                inconsistent_lines.append(info)
        
        # Report mixed lines first (tabs AND spaces on same line)
        for info in mixed_lines:
            autofix_edit = self._generate_line_autofix(info, style, width)
            finding = Finding(
                rule=self.meta.id,
                message=f"Line {info['line_num']} mixes tabs and spacesâ€”use one or the other.",
                severity="info",
                file=ctx.file_path,
                start_byte=info['start_byte'],
                end_byte=info['end_byte'],
                autofix=[autofix_edit] if autofix_edit else None,
                meta={
                    "line_number": info['line_num'],
                    "whitespace": repr(info['whitespace']),
                    "issue": "mixed_on_line"
                }
            )
            findings.append(finding)
        
        # Report inconsistent style lines (limit to first 5 to avoid spam)
        for info in inconsistent_lines[:5]:
            autofix_edit = self._generate_line_autofix(info, style, width)
            issue_type = "uses_spaces" if style == "tabs" else "uses_tabs"
            finding = Finding(
                rule=self.meta.id,
                message=f"Line {info['line_num']} uses {'spaces' if info['has_spaces'] else 'tabs'} but rest of file uses {'tabs' if style == 'tabs' else 'spaces'}.",
                severity="info",
                file=ctx.file_path,
                start_byte=info['start_byte'],
                end_byte=info['end_byte'],
                autofix=[autofix_edit] if autofix_edit else None,
                meta={
                    "line_number": info['line_num'],
                    "whitespace": repr(info['whitespace']),
                    "issue": issue_type,
                    "preferred_style": style
                }
            )
            findings.append(finding)
        
        # If there are more inconsistent lines, add a summary
        if len(inconsistent_lines) > 5:
            remaining = len(inconsistent_lines) - 5
            findings.append(Finding(
                rule=self.meta.id,
                message=f"...plus {remaining} more lines with inconsistent indentation.",
                severity="info", 
                file=ctx.file_path,
                start_byte=0,
                end_byte=0,
                meta={
                    "total_inconsistent": len(inconsistent_lines),
                    "preferred_style": style
                }
            ))
        
        return findings
    
    def _collect_indentation_info(self, text: str) -> List[dict]:
        """
        Collect indentation information for each line.
        Returns list of dicts with line info.
        """
        info_list = []
        lines = text.split('\n')
        byte_offset = 0
        
        for line_num, line in enumerate(lines, start=1):
            # Skip empty lines
            if not line.strip():
                byte_offset += len(line) + 1  # +1 for newline
                continue
            
            # Find leading whitespace
            match = re.match(r'^([ \t]+)', line)
            if match:
                whitespace = match.group(1)
                start_byte = byte_offset
                end_byte = byte_offset + len(whitespace)
                info_list.append({
                    'line_num': line_num,
                    'start_byte': start_byte,
                    'end_byte': end_byte,
                    'whitespace': whitespace,
                    'has_tabs': '\t' in whitespace,
                    'has_spaces': ' ' in whitespace
                })
            
            byte_offset += len(line) + 1  # +1 for newline
        
        return info_list
    
    def _collect_indentation_runs(self, text: str) -> List[Tuple[int, int, str]]:
        """
        Collect all indentation runs at the beginning of lines.
        Returns list of (start_byte, end_byte, whitespace_text) tuples.
        Legacy method for compatibility.
        """
        info_list = self._collect_indentation_info(text)
        return [(info['start_byte'], info['end_byte'], info['whitespace']) 
                for info in info_list]
    
    def _infer_preferred_style(self, info_list: List[dict]) -> Tuple[str, int]:
        """
        Infer the preferred indentation style from collected indentation info.
        Returns (style, width) where style is 'tabs' or 'spaces' and width is the space width.
        Accepts either list of dicts (new format) or list of tuples (legacy format).
        """
        tab_lines = 0
        space_lines = 0
        space_lengths = []
        
        for item in info_list:
            # Support both dict and tuple formats
            if isinstance(item, dict):
                whitespace = item['whitespace']
                has_tabs = item['has_tabs']
                has_spaces = item['has_spaces']
            else:
                # Legacy tuple format: (start, end, whitespace)
                whitespace = item[2]
                has_tabs = '\t' in whitespace
                has_spaces = ' ' in whitespace
            
            if has_tabs and not has_spaces:
                tab_lines += 1
            elif has_spaces and not has_tabs:
                space_lines += 1
                space_lengths.append(len(whitespace))
            # Mixed on same line counts toward both
            else:
                if has_tabs:
                    tab_lines += 1
                if has_spaces:
                    space_lines += 1
                    # Count only the space portion
                    space_count = whitespace.count(' ')
                    if space_count > 0:
                        space_lengths.append(space_count)
        
        # Determine preferred style
        if tab_lines > space_lines:
            return ("tabs", 0)
        
        # Infer space width using GCD
        if space_lengths:
            width = 0
            for length in space_lengths:
                if length > 0:
                    width = gcd(width, length)
            
            # Clamp to common widths
            if width not in [2, 4]:
                width = 4 if width == 0 or width > 4 else 2
        else:
            width = 4  # Default
        
        return ("spaces", width)
    
    def _generate_line_autofix(self, info: dict, style: str, width: int) -> Optional[Edit]:
        """Generate an autofix edit for a single line's indentation."""
        whitespace = info['whitespace']
        start_byte = info['start_byte']
        end_byte = info['end_byte']
        
        # Calculate visual depth
        if style == "tabs":
            # Convert to tabs: count current depth and use that many tabs
            depth = self._calculate_visual_depth(whitespace, width if width > 0 else 4)
            replacement = '\t' * depth
        else:
            # Convert to spaces: count current depth and multiply by width
            depth = self._calculate_visual_depth(whitespace, width)
            replacement = ' ' * (depth * width)
        
        # Only create edit if replacement is different
        if replacement != whitespace:
            return Edit(
                start_byte=start_byte,
                end_byte=end_byte,
                replacement=replacement
            )
        return None
    
    def _calculate_visual_depth(self, whitespace: str, space_width: int) -> int:
        """Calculate the visual indentation depth of a whitespace string."""
        tab_count = whitespace.count('\t')
        space_count = whitespace.count(' ')
        
        # Each tab counts as 1 depth unit
        # Spaces are grouped by space_width
        space_depth = (space_count + space_width - 1) // space_width if space_width > 0 else 0
        
        return tab_count + space_depth
    
    def _generate_autofix(self, runs: List[Tuple[int, int, str]]) -> Optional[List[Edit]]:
        """Generate autofix edits to normalize indentation."""
        if not runs:
            return None
        
        style, width = self._infer_preferred_style(runs)
        edits = []
        
        for start_byte, end_byte, whitespace in runs:
            # Calculate visual depth
            if style == "tabs":
                # Convert to tabs: count current depth and use that many tabs
                depth = self._calculate_visual_depth(whitespace, width if width > 0 else 4)
                replacement = '\t' * depth
            else:
                # Convert to spaces: count current depth and multiply by width
                depth = self._calculate_visual_depth(whitespace, width)
                replacement = ' ' * (depth * width)
            
            # Only create edit if replacement is different
            if replacement != whitespace:
                edits.append(Edit(
                    start_byte=start_byte,
                    end_byte=end_byte,
                    replacement=replacement
                ))
        
        # Sort edits by start_byte in descending order to avoid offset issues
        edits.sort(key=lambda e: e.start_byte, reverse=True)
        
        return edits if edits else None


# Register this rule when the module is imported
try:
    from ..engine.registry import register_rule
except ImportError:
    try:
        from engine.registry import register_rule
    except ImportError:
        # For test execution - registry may not be available
        def register_rule(rule):
            pass

register_rule(StyleMixedIndentationRule())


